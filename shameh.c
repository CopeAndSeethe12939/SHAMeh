/*
	                                                                                                                                        
           ▓▓▓▓▓▓▓          ▓▓▓▓▓  ▓▓▓▓▓▓▓▓       ▓▓▓▓▓▓▓                 ▓▓▓▓▓            ▓▓▓▓▓     ▓▓▓▓▓▓▓▓▓▓    ▓▓▓▓▓   ▓▓▓▓▓▓▓      
        ▓▓▓██▓████▓▓▓    ▓▓▓██▓██  ▓█▓██▓▓▓    ▓▓▓██▓████▓▓▓             ▓██▓██            ▓████▓ ▓▓▓██▓▓▓████▓  ▓▓██▓██▓ ▓▓▓▓█▓██▓     
      ▓▓▓████▓██████▓▓▓  ▓████▓██  ▓██████▓  ▓▓▓█▓██▓██████▓▓▓           ▓██▓██▓▓▓       ▓▓▓████▓ ▓████▓██████▓ ▓████▓██▓ ▓████▓██▓     
     ▓██▓████▓ ▓████▓██▓ ▓████▓██  ▓█▓██▓█▓ ▓██▓█▓██▓ ▓████▓██▓          ▓██▓████▓      ▓██▓████▓ ▓█▓██▓██      ▓████▓██▓ ▓████▓██▓     
     ▓██▓█▓██▓ ▓██▓█▓██▓ ▓████▓██  ▓█▓██▓█▓ ▓██▓█▓██▓ ▓████▓██▓          ▓██▓████▓▓▓  ▓▓▓██▓█▓██▓ ▓█▓██▓█▓      ▓████▓██▓ ▓████▓██▓     
     ▓▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓          ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓      ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓     
     ▓▓▓▓▓▓▓▓▓▓▓▓▓▓      ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▒▓▓▓ ▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓     
        ▓▒▒▒▒▓▒▒▒▒▓▓▓    ▓▒▒▒▒▓▒▒▒▒▓▒▒▒▒▓▒▒ ▓▒▒▒▒▓▒▒▓ ▓▒▒▒▒▓▒▒▓ ▒▒▒▒▒▓▒▒ ▓▒▒▓▒▒▒▒▓▒▒▒▒▒▒▒▒▒▓▒▒▒▒▓ ▓▒▒▒▒▓▒▒▒▒▒▒▒ ▓▒▒▒▒▓▒▒▓▒▓▒▒▒▒▓▒▒▓     
          ▓▒▒▓▓▓▒▒▓▒▓▓▓▓ ▓▒▓▓▒▓▒▒▒▒▓▓▓▒▒▓▒▒ ▓▒▒▓▓▓▒▒▓▓▓▓▓▓▓▓▒▒▓ ▓▓▓▓▓▓▓▓ ▓▒▒▓▓▓▒▒▓▒▒▒▒▓▒▓▒▓▓▒▒▒▒▓ ▓▓▓▓▒▓▒▒▒▒▓▒▓ ▓▒▒▓▒▓▓▓▓▒▓▒▒▒▒▓▒▒▓     
             ▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓ ▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓          ▓▓▓▓▓▓▓▓▓ ▓▓▓▓ ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓      ▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓     
      ▒▓▒▒▒▒▓▒ ▒▒▓▒▒▒▒▓▒ ▒▒▓▒▓▒▓▓  ▒▒▓▒▓▒▓▒ ▒▒▓▒▒▒▒▓▒▒▒▒▓▒▓▒▒▓▒          ▒▒▓▒▒▓▒▓▒      ▒▒▓▒▒▒▒▓▒ ▒▒▓▒▓▒▓▓      ▒▒▓▒▓▒▒▓▒ ▒▒▓▒▓▒▒▓▒     
     ▒▒▓▒▒▓▒▓▒ ▒▒▓▒▒▒▒▓▒ ▒▒▓▒▓▒▒▓  ▒▒▓▒▓▒▓▓ ▒▒▓▒▒▓▒▓▒ ▒▒▓▒▒▒▒▓▒          ▒▒▓▒▒▓▒▓▒      ▒▒▓▒▒▓▒▓▒ ▒▒▓▒▓▒▓▓      ▒▒▓▒▒▒▒▓▒ ▒▒▓▒▓▒▒▓▒     
     ▒▒▓▒▒▓▒█▒ ▒▒▓▒▒▒▒█▒ ▒▒█▒▓▒▓█  ▒▒▓▒▓▒▓▓ ▒▒▓▒▒▓▒█▒ ▒▒█▒▒▒▒█▒          ▒▒▓▒▒█▒▓▒      ▒▒█▒▒▓▒█▒ ▒▒▓▒█▒▓▓      ▒▒▓▒▒▒▒█▒ ▒▒█▒▒▒▒█▒     
     ▒▒▒▒▒▓▒█▒ ▒▒▓▒▒▒▒█▒ ▒▒█▒▓▒▓█  ▒▒▓▒█▒▓▓ ▒▒▓▒▒▓▒█▒ ▒▒▓▒▒▒▒█▒          ▒▒▒▒▒▓▒█▒      ▒▒▓▒▒▓▒█▒ ▒▒▓▒█▒▓▓      ▒▒█▒▒▒▒█▒ ▒▒▓▒▒▒▒█▒     
      ▒▒▒▒▓▒▒▒▒▓▒▒▒█▒▒▒  ▒▒▓▒▒▒▒█  ▒▒▓▒▒▒▓▓  ▒▒▒▒▓▒▓▒  ▒▒▒▒▒▒█▒           ▒▒▒▒▓▒█▒       ▒▒▒▒▓▒█▒ ▒▒▓▒▒▒▒▓ ▒▒█▒  ▒▒▒▒▒▒▓▒  ▒▓▒▒▒▒█▒     
        ▒▒▒▒▒▒▒█▒█▒▒▒    ▒▒█▒▒▒▒█  ▒▒▓▒▒▒▓▓  ▒▒▒▒▓▒█▒  ▒▒▒▒▒▒█▒           ▒▒▒▒█▒█▒       ▒▒▒▒▓▒█▒ ▒▒▓▒▒▒▒█▒▒▒█▓  ▒▒▒▒▒▒█▒  ▒▒▒▒▒▒█▒     
           ▒▒▒▒▒▒▒       ▒▒▒▒▒▒▒▒  ▒▒▒▒▒▒▒▒  ▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒            ▒▒▒▒▒▒▒▒       ▒▒▒▒▒▒▒  ▒▒▒▒▒▒▒▒▒▒▒▒▒  ▒▒▒▒▒▒▒   ▒▒▒▒▒▒▒      
                                                                                                        
                                    			Secure Hash Algorithm Mass encryption hack
	
								PoC by: The_Original_Sin

Q: What is it ?
A: It's the next generation (whatever is beyond bleeding edge) brute force algorithm using secure encryption to break secure encyption based from SHA256 (as it dumps out 32 bytes), which is more than enough for combination attacks. I utilised something similar in my "Wild Brute Force" routine many years ago to great success.

Q: Why is it useful ?
A: It speeds up brute force attacks at an extreme rate by generating "random looking" passes that are based of hashed sequential numbers, which in turn, are rolled - thus 1 input generates 190 "random looking" results all from 1 SHA, and a lot of bit abuse. Because of the low CPU overhead needed (1 hash per 190 guesses) it can run quite comfortably on an old mobile phone, or a Raspberry PI, or your smart toaster.

Q: What is the "list.h" file ?
A: All possible 4 digit combinations from YouTubes stream key generator (4 characters * 5 sets (20 characters) seperated by a hyphen (24 total characters)). As the total number of entries does not exceed 1679616 (0x19a100) bytes (that's 3) in length - we use a list of 4 characters per entry which is selected by 3 from the SHA & Roll result. In this case, an 8Mb wordlist file is all we need to brute every possible streamkey combination. Of course, we could remove 3 & 4 length dupes from the list.h if we wanted to streamline it further - but hey, at this point, we can take the piss.

To further explain, YouTube uses 0-9 and a-z in the keys (like many other streaming services) which is only 36 characters. A single byte value being up to 255 means there is a LOT of redundancy of bit usage, this method streamlines that process down, thus 3 bytes become 4 in the output, which is originally generated by the initial input to the SHA (which could even be 1 byte). By ROLLing the SHA (32 (characters) * 8 (bits) times per run) each run creating 190 outputs. Even if they was to incorporate uppercase and symbols, there will still be a LOT of redundancy we can abuse. Typically ASCII uses no more than 127 different characters which is 50% redundancy at best.

Q: Can I use this to hack a live YouTube stream ?
A: I don't know, can you ? I mean you'd have to insert your own loop for the initial SHA generation (see SHA256_TEST subroutine) and pipe the output to openrtmp while rotating proxies, then inject your own advert/video - but it's not as if those routines already exist - right kids ;)

Q: Can I hack XYZ service with this ?
A: Maybe, I dunno, i'm not psychic. This is written in a very basic way that even a skiddy could follow it. Merely create your own list.h, and adjust the code accordingly.

Q: Is it illegal to use ?
A: Only if you get caught doing something dumb (duh!). Otherwise, nope ! It's a proof of concept that does nothing other than generate POSSIBLE streamkeys for YouTube. It has no way to connect to any service, thus is not breaking any law - just security logic.

Q: I get warnings when compiling, why ?
A: Because the word Crap starts with C. This is a PoC, thus only a quick mock up of my idea, and not an example of coding. The method I use here is of more importance than the code as it demonstrates how stupid security is these days, and how easy it is to break. Especially when people use junk like RUST or Python. You could probably break that RPC backdoor in Discord easily with this if you cared enough.

To compile;

gcc -Wall shameh.c -o shameh

Tested on Kali (kinda' janky OS, won't lie) - should work on everything else, unless your system is total junk.

> SHA256 routine stolen from Brad Conte (who probably copied it from the RFC anyway, but credit where credit is due)
> Rest by The_Original_Sin

*/

#include "list.h" //Pregenerated partial password list
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <stddef.h>

#define SHA256_BLOCK_SIZE 32            // SHA256 outputs a 32 byte digest

typedef unsigned char BYTE;             // 8-bit byte
typedef unsigned int  WORD;             // Cameo

typedef struct {
	BYTE data[64];
	WORD datalen;
	unsigned long long bitlen;
	WORD state[8];
} SHA256_CTX;

void sha256_init(SHA256_CTX *ctx);
void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len);
void sha256_final(SHA256_CTX *ctx, BYTE hash[]);

BYTE buf[SHA256_BLOCK_SIZE];	// Hash stored here
BYTE mask[SHA256_BLOCK_SIZE];	// Hash roll mask stored here
BYTE ubuf[SHA256_BLOCK_SIZE];	// Hash roll update stored here

// Was so tempted to inline ASM this, but speed is not of importance here
#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))
#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))

#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))

static const WORD k[64] = {
	0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
	0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
	0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
	0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
	0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
	0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
	0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
	0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
};

void sha256_transform(SHA256_CTX *ctx, const BYTE data[])
{
	WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

	for (i = 0, j = 0; i < 16; ++i, j += 4)
		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
	for ( ; i < 64; ++i)
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];

	a = ctx->state[0];
	b = ctx->state[1];
	c = ctx->state[2];
	d = ctx->state[3];
	e = ctx->state[4];
	f = ctx->state[5];
	g = ctx->state[6];
	h = ctx->state[7];

	for (i = 0; i < 64; ++i) {
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
		t2 = EP0(a) + MAJ(a,b,c);
		h = g;
		g = f;
		f = e;
		e = d + t1;
		d = c;
		c = b;
		b = a;
		a = t1 + t2;
	}

	ctx->state[0] += a;
	ctx->state[1] += b;
	ctx->state[2] += c;
	ctx->state[3] += d;
	ctx->state[4] += e;
	ctx->state[5] += f;
	ctx->state[6] += g;
	ctx->state[7] += h;
}

void sha256_init(SHA256_CTX *ctx)
{
	ctx->datalen = 0;
	ctx->bitlen = 0;
	ctx->state[0] = 0x6a09e667;
	ctx->state[1] = 0xbb67ae85;
	ctx->state[2] = 0x3c6ef372;
	ctx->state[3] = 0xa54ff53a;
	ctx->state[4] = 0x510e527f;
	ctx->state[5] = 0x9b05688c;
	ctx->state[6] = 0x1f83d9ab;
	ctx->state[7] = 0x5be0cd19;
}

void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len)
{
	WORD i;

	for (i = 0; i < len; ++i) {
		ctx->data[ctx->datalen] = data[i];
		ctx->datalen++;
		if (ctx->datalen == 64) {
			sha256_transform(ctx, ctx->data);
			ctx->bitlen += 512;
			ctx->datalen = 0;
		}
	}
}

void sha256_final(SHA256_CTX *ctx, BYTE hash[])
{
	WORD i;

	i = ctx->datalen;

	// Pad whatever data is left in the buffer.
	if (ctx->datalen < 56) {
		ctx->data[i++] = 0x80;
		while (i < 56)
			ctx->data[i++] = 0x00;
	}
	else {
		ctx->data[i++] = 0x80;
		while (i < 64)
			ctx->data[i++] = 0x00;
		sha256_transform(ctx, ctx->data);
		memset(ctx->data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	ctx->bitlen += ctx->datalen * 8;
	ctx->data[63] = ctx->bitlen;
	ctx->data[62] = ctx->bitlen >> 8;
	ctx->data[61] = ctx->bitlen >> 16;
	ctx->data[60] = ctx->bitlen >> 24;
	ctx->data[59] = ctx->bitlen >> 32;
	ctx->data[58] = ctx->bitlen >> 40;
	ctx->data[57] = ctx->bitlen >> 48;
	ctx->data[56] = ctx->bitlen >> 56;
	sha256_transform(ctx, ctx->data);

	// Since this implementation uses little endian byte ordering and SHA uses big endian,
	// reverse all the bytes when copying the final state to the output hash.
	for (i = 0; i < 4; ++i) {
		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
	}
}



/*
	This is where you'd next the normal brute routine, you're welcome.
	This section is part of Brads original code which was to test the SHA256 was working (it did) so I left it in more as
	a starting place for you to work from if you want to rip this code off	
*/

int sha256_test()
{
	BYTE text3[] = {"aaaaaaaaaa"};
	BYTE hash3[SHA256_BLOCK_SIZE] = {0xcd,0xc7,0x6e,0x5c,0x99,0x14,0xfb,0x92,0x81,0xa1,0xc7,0xe2,0x84,0xd7,0x3e,0x67,
	                                 0xf1,0x80,0x9a,0x48,0xa4,0x97,0x20,0x0e,0x04,0x6d,0x39,0xcc,0xc7,0x11,0x2c,0xd0};
	SHA256_CTX ctx;
	int idx;
	int pass = 1;

	sha256_init(&ctx);
	for (idx = 0; idx < 100000; ++idx)
	   sha256_update(&ctx, text3, strlen(text3));
	sha256_final(&ctx, buf);
	pass = pass && !memcmp(hash3, buf, SHA256_BLOCK_SIZE);

	return(pass);
}

// Roll 32 bytes by 1 bit - bitops on C seems weird
void roller()
{
	int cnt =0;
	do {
	if ((buf [cnt] & 128) == 128) 	{ mask [cnt] = 1; } else  { mask [cnt] = 0; }
	if ((buf[cnt+1] & 128) == 128) 	{ ubuf [cnt] = ((buf[cnt]) << 1) | 1; } else { ubuf [cnt] = ((buf[cnt]) << 1); }
	cnt++;
	} while (cnt !=32);
	ubuf [31] = ((buf[31] << 1)) | mask [0];
}

int main()
{
	int PASS_TOP = sizeof(hashes) / sizeof(hashes[0]); 	// Get max pre-generated list entries
	int cnt = 0;						// Generic counter
	int v0,v1,v2,v3 = 0;					// Part 1 of stream key
	int w0,w1,w2,w3 = 0;					// Part 2 of stream key
	int x0,x1,x2,x3 = 0;					// Part 3 of stream key
	int y0,y1,y2,y3 = 0;					// Part 4 of stream key
	int z0,z1,z2,z3 = 0;					// Part 5 of stream key
	char* guess[24];					// Where we store the generated streamkey
	int max = 0;						// Some weird sounding dude I know of
	
	sha256_test(); // Generate the SHA256
		
	max = (32*8); 	// How many times to roll the SHA. 32 bytes, 8 bits per bytes, plus 1 as we ROLL early
			// If you add 1 more to this value, you'll repeat the first output which is how you know it works
	do
	{	
		roller ();	// Yes, we ROLL our own. Better than pre-rolled. I'm talking about tobacco stuff here

		// Debug bit left in for lulz

/*		cnt = 0;
		printf("\n");
		do {
		printf ("Pos:%02x BUF = %02x, UBUF = %02x, ROL = %i\n", cnt, buf[cnt],ubuf[cnt],mask[cnt]);
		cnt ++;
		} while (cnt !=32); */

		// Ugly skiddyesque code more for clarity

		v1 = (ubuf[0]);
		v2 = (ubuf[1]) * 256;
		v3 = (ubuf[2]) * 65536;
		v0 = v1+v2+v3;
		while (v0 > PASS_TOP) { v0 = v0 - PASS_TOP; }

		w1 = (ubuf[3]);
		w2 = (ubuf[4]) * 256;
		w3 = (ubuf[5]) * 65536;
		w0 = w1+w2+w3;
		while (w0 > PASS_TOP) { w0 = w0 - PASS_TOP; }
	
		x1 = (ubuf[6]);
		x2 = (ubuf[7]) * 256;
		x3 = (ubuf[8]) * 65536;
		x0 = x1+x2+x3;
		while (x0 > PASS_TOP) { x0 = x0 - PASS_TOP; }
	
		y1 = (ubuf[9]);
		y2 = (ubuf[10]) * 256;
		y3 = (ubuf[11]) * 65536;
		y0 = y1+y2+y3;
		while (y0 > PASS_TOP) { y0 = y0 - PASS_TOP; }
	
		z1 = (ubuf[12]);
		z2 = (ubuf[13]) * 256;
		z3 = (ubuf[14]) * 65536;
		z0 = z1+z2+z3;
		while (z0 > PASS_TOP) { z0 = z0 - PASS_TOP; }
	
		sprintf (guess,"%s-%s-%s-%s-%s",hashes[v0],hashes[w0],hashes[x0],hashes[y0],hashes[z0]);
		
		// At this point, "guess" contains the actual streamkey output and could be piped elsewhere
		// That's right - this is where you would lay the pipe to YouTube, who deserve it for theft - AHEM
		
		printf ("Current: %s\n",guess);

		cnt = 0;
		do {
		buf[cnt] = ubuf[cnt];
		cnt ++;
		} while (cnt != 32);
		
	
		max --; // Decrease the value of max until max is no more :D 
	} while (max > 0);
	
	// Bye bye	
	return(0);
}
